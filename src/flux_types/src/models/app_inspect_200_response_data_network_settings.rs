/*
 * Flux
 *
 * This is an API documentation of calls available to be made to any Flux. <br> GET Calls are available as both query and in order as path. <br> Flux is completely open source and we encourage everyone to feel free and contribute :) <br> Further questions or support join and ask in our [discord](https://discord.io/runonflux)  # Introduction Flux possesses a 5 tier hiearchy level API. * **Public** API level - Available without any permission, does not require signing. * **User** API level - User level permission, requires signing. * **FluxTeam** API level - FluxTeam level permission (an appointed Flux Team member has access to those API calls), requires signing. * **Admin** API level - Admin level permission, requires signing. Flux owner. * **AdminAndFluxTeam** API level permission (Admin and Flux Team has access to these calls), requires signing. * **AppOwner** API level - AppOwner level permission, requires signing. App Owner. * **AppOwnerAbove** API level - AppOwnerAbove level permission (App Owner, FluxTeam, and Admin has access to these calls), requires signing.  Most calls are available via GET request with some that may require large amount of data via POST request. Websocket is currently used only for simplifying login operations and for internal Flux communication. # Getting Started with the API * **1. Install Zelcore Wallet:** The Zelcore wallet is required for signing messages. Please install this if not already installed. * **2. Create Zelcore Account:** A Zelcore wallet account is required for signing messages. Please register an account if you don't already have one. * **3. Obtain API Authentication Credentials:** Follow the Authentication section of this API documentation in order to set up your credentials for using the rest of the API. You will need to use your Zelcore wallet for parts of this process. * **4. Set Up Authentication Credentials in Header:** Set up your zelidauth credentials in your header. If you are using variables, the signature value may need to be URLencoded.
 *
 * The version of the OpenAPI document: 4.9.1
 * Contact: tadeas@runonflux.io
 * Generated by: https://openapi-generator.tech
 */

/// AppInspect200ResponseDataNetworkSettings : NetworkSettings exposes the network settings in the API



#[derive(Clone, Debug, PartialEq, Serialize, Deserialize)]
pub struct AppInspect200ResponseDataNetworkSettings {
    /// Name of the network's bridge
    #[serde(rename = "Bridge", skip_serializing_if = "Option::is_none")]
    pub bridge: Option<String>,
    /// SandboxID uniquely represents a container's network stack
    #[serde(rename = "SandboxID", skip_serializing_if = "Option::is_none")]
    pub sandbox_id: Option<String>,
    /// Indicates if hairpin NAT should be enabled on the virtual interface
    #[serde(rename = "HairpinMode", skip_serializing_if = "Option::is_none")]
    pub hairpin_mode: Option<bool>,
    /// IPv6 unicast address using the link-local prefix
    #[serde(rename = "LinkLocalIPv6Address", skip_serializing_if = "Option::is_none")]
    pub link_local_ipv6_address: Option<String>,
    /// Prefix length of the IPv6 unicast address
    #[serde(rename = "LinkLocalIPv6PrefixLen", skip_serializing_if = "Option::is_none")]
    pub link_local_ipv6_prefix_len: Option<i32>,
    /// PortMap describes the mapping of container ports to host ports, using the container's port-number and protocol as key. If a container's port is mapped for multiple protocols, separate entries are added to the mapping table.
    #[serde(rename = "Ports", skip_serializing_if = "Option::is_none")]
    pub ports: Option<::std::collections::HashMap<String, Vec<crate::models::AppInspect200ResponseDataNetworkSettingsPortsValueInner>>>,
    /// SandboxKey identifies the sandbox
    #[serde(rename = "SandboxKey", skip_serializing_if = "Option::is_none")]
    pub sandbox_key: Option<String>,
    #[serde(rename = "SecondaryIPAddresses", skip_serializing_if = "Option::is_none")]
    pub secondary_ip_addresses: Option<Vec<crate::models::AppInspect200ResponseDataNetworkSettingsSecondaryIpAddressesInner>>,
    #[serde(rename = "SecondaryIPv6Addresses", skip_serializing_if = "Option::is_none")]
    pub secondary_ipv6_addresses: Option<Vec<crate::models::AppInspect200ResponseDataNetworkSettingsSecondaryIpAddressesInner>>,
    /// EndpointID uniquely represents a service endpoint in a Sandbox
    #[serde(rename = "EndpointID", skip_serializing_if = "Option::is_none")]
    pub endpoint_id: Option<String>,
    /// Gateway address for the default \"bridge\" network
    #[serde(rename = "Gateway", skip_serializing_if = "Option::is_none")]
    pub gateway: Option<String>,
    /// Global IPv6 address for the default \"bridge\" network
    #[serde(rename = "GlobalIPv6Address", skip_serializing_if = "Option::is_none")]
    pub global_ipv6_address: Option<String>,
    /// Mask length of the global IPv6 address
    #[serde(rename = "GlobalIPv6PrefixLen", skip_serializing_if = "Option::is_none")]
    pub global_ipv6_prefix_len: Option<i32>,
    /// IPv4 address for the default \"bridge\" network
    #[serde(rename = "IPAddress", skip_serializing_if = "Option::is_none")]
    pub ip_address: Option<String>,
    /// Mask length of the IPv4 address
    #[serde(rename = "IPPrefixLen", skip_serializing_if = "Option::is_none")]
    pub ip_prefix_len: Option<i32>,
    /// IPv6 gateway address for this network
    #[serde(rename = "IPv6Gateway", skip_serializing_if = "Option::is_none")]
    pub ipv6_gateway: Option<String>,
    /// MAC address for the container on the default \"bridge\" network
    #[serde(rename = "MacAddress", skip_serializing_if = "Option::is_none")]
    pub mac_address: Option<String>,
    #[serde(rename = "Networks", skip_serializing_if = "Option::is_none")]
    pub networks: Option<Box<crate::models::AppInspect200ResponseDataNetworkSettingsNetworks>>,
}

impl AppInspect200ResponseDataNetworkSettings {
    /// NetworkSettings exposes the network settings in the API
    pub fn new() -> AppInspect200ResponseDataNetworkSettings {
        AppInspect200ResponseDataNetworkSettings {
            bridge: None,
            sandbox_id: None,
            hairpin_mode: None,
            link_local_ipv6_address: None,
            link_local_ipv6_prefix_len: None,
            ports: None,
            sandbox_key: None,
            secondary_ip_addresses: None,
            secondary_ipv6_addresses: None,
            endpoint_id: None,
            gateway: None,
            global_ipv6_address: None,
            global_ipv6_prefix_len: None,
            ip_address: None,
            ip_prefix_len: None,
            ipv6_gateway: None,
            mac_address: None,
            networks: None,
        }
    }
}


