/*
 * Flux
 *
 * This is an API documentation of calls available to be made to any Flux. <br> GET Calls are available as both query and in order as path. <br> Flux is completely open source and we encourage everyone to feel free and contribute :) <br> Further questions or support join and ask in our [discord](https://discord.io/runonflux)  # Introduction Flux possesses a 5 tier hiearchy level API. * **Public** API level - Available without any permission, does not require signing. * **User** API level - User level permission, requires signing. * **FluxTeam** API level - FluxTeam level permission (an appointed Flux Team member has access to those API calls), requires signing. * **Admin** API level - Admin level permission, requires signing. Flux owner. * **AdminAndFluxTeam** API level permission (Admin and Flux Team has access to these calls), requires signing. * **AppOwner** API level - AppOwner level permission, requires signing. App Owner. * **AppOwnerAbove** API level - AppOwnerAbove level permission (App Owner, FluxTeam, and Admin has access to these calls), requires signing.  Most calls are available via GET request with some that may require large amount of data via POST request. Websocket is currently used only for simplifying login operations and for internal Flux communication. # Getting Started with the API * **1. Install Zelcore Wallet:** The Zelcore wallet is required for signing messages. Please install this if not already installed. * **2. Create Zelcore Account:** A Zelcore wallet account is required for signing messages. Please register an account if you don't already have one. * **3. Obtain API Authentication Credentials:** Follow the Authentication section of this API documentation in order to set up your credentials for using the rest of the API. You will need to use your Zelcore wallet for parts of this process. * **4. Set Up Authentication Credentials in Header:** Set up your zelidauth credentials in your header. If you are using variables, the signature value may need to be URLencoded.
 *
 * The version of the OpenAPI document: 4.9.1
 * Contact: tadeas@runonflux.io
 * Generated by: https://openapi-generator.tech
 */




#[derive(Clone, Debug, PartialEq, Serialize, Deserialize)]
pub struct ListtransactionsInner {
    /// The account name associated with the transaction. Will be \"\" for the default account
    #[serde(rename = "account", skip_serializing_if = "Option::is_none")]
    pub account: Option<String>,
    /// The Flux address of the transaction. Not present for move transactions (category = move)
    #[serde(rename = "address", skip_serializing_if = "Option::is_none")]
    pub address: Option<String>,
    /// The transaction category. 'send' has negative amounts, 'receive' has positive amounts
    #[serde(rename = "category", skip_serializing_if = "Option::is_none")]
    pub category: Option<String>,
    /// The amount in FLUX. This is negative for the 'send' category, and for the 'move' category for moves outbound. It is positive for the 'receive' category, and for the 'move' category for inbound funds.
    #[serde(rename = "amount", skip_serializing_if = "Option::is_none")]
    pub amount: Option<f32>,
    /// Vout value
    #[serde(rename = "vout", skip_serializing_if = "Option::is_none")]
    pub vout: Option<i32>,
    /// The number of confirmations for the transaction. Available for 'send' and 'receive' category of transactions
    #[serde(rename = "fee", skip_serializing_if = "Option::is_none")]
    pub fee: Option<f32>,
    /// The number of confirmations for the transaction. Available for 'send' and 'receive' category of transactions
    #[serde(rename = "confirmations", skip_serializing_if = "Option::is_none")]
    pub confirmations: Option<i32>,
    /// The block hash containing the transaction. Available for 'send' and 'receive' category of transactions
    #[serde(rename = "blockhash", skip_serializing_if = "Option::is_none")]
    pub blockhash: Option<String>,
    /// The block index containing the transaction. Available for 'send' and 'receive' category of transactions
    #[serde(rename = "blockindex", skip_serializing_if = "Option::is_none")]
    pub blockindex: Option<i32>,
    /// The block time in seconds since epoch (1 Jan 1970 GMT)
    #[serde(rename = "blocktime", skip_serializing_if = "Option::is_none")]
    pub blocktime: Option<i32>,
    /// Expiry height of transaction
    #[serde(rename = "expiryheight", skip_serializing_if = "Option::is_none")]
    pub expiryheight: Option<i32>,
    /// The transaction id. Available for 'send' and 'receive' category of transactions
    #[serde(rename = "txid", skip_serializing_if = "Option::is_none")]
    pub txid: Option<String>,
    #[serde(rename = "walletconflicts", skip_serializing_if = "Option::is_none")]
    pub walletconflicts: Option<Vec<serde_json::Value>>,
    /// The transaction time in seconds since epoch (Jan 1 1970 GMT)
    #[serde(rename = "time", skip_serializing_if = "Option::is_none")]
    pub time: Option<i32>,
    /// The time received in seconds since epoch (Jan 1 1970 GMT)
    #[serde(rename = "timereceived", skip_serializing_if = "Option::is_none")]
    pub timereceived: Option<i32>,
    #[serde(rename = "vJoinSplit", skip_serializing_if = "Option::is_none")]
    pub v_join_split: Option<Vec<crate::models::JoinsplitInner>>,
    /// Size in bytes
    #[serde(rename = "size", skip_serializing_if = "Option::is_none")]
    pub size: Option<i32>,
}

impl ListtransactionsInner {
    pub fn new() -> ListtransactionsInner {
        ListtransactionsInner {
            account: None,
            address: None,
            category: None,
            amount: None,
            vout: None,
            fee: None,
            confirmations: None,
            blockhash: None,
            blockindex: None,
            blocktime: None,
            expiryheight: None,
            txid: None,
            walletconflicts: None,
            time: None,
            timereceived: None,
            v_join_split: None,
            size: None,
        }
    }
}


